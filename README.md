websh
========================================

webサーバをbashスクリプトと一般的なツールの組み合わせで作成する試みのプロジェクトです。

## 含まれるスクリプトについて

### 1. 静的なHello Worldサーバ

nc を利用します。

どのようなリクエストに対してもHello World を返します。

ほぼ、以下のコードと同等です。

    while true; do ( echo 'HTTP/1.0 200 OK';echo;echo 'Hello World'; ) | nc -l 10080; done

### 2. 動的な Hello World サーバ

nc を利用します。

リクエスト毎に異なる結果を返します。

また、接続に対してアクセスログを標準エラー出力に書き出します。bashの配列を利用し、HTTPヘッダを処理します。


### 3. 簡単な web サーバ

nc を利用します。

ドキュメントルートとなるディレクトリを起点として、要求されたパスのファイルの内容を返します。

要求されたパスの拡張子をもとに、コンテンツタイプを適切に設定して返すことにより、html や画像の表示が可能です。


### 4. 複数接続可能なサーバ

socat を利用します。

`sudo port install socat` とか `sudo brew install socat` やって socat をインストールします。yum や apt でもインストールできるので、適宜パッケージを導入します。このプロジェクト作成時は ver 2系はまだベータが取れてないので、おとなしく 1.7系の最新版を利用します。

socat は nc を fork することで複数のリクエストを同時に処理することができるため、HTMLの解析中に同期的に接続が実行される css や img 、javascript を処理することができます。


### 5. 少し動的なサーバ

リクエストが / で終わる場合に /index.html があればそちらの内容を返します。また、index.html がない場合、ディレクトリ内ファイルのリスティングを行います。

存在しないパスが指定された場合、数秒でトップ画面へ遷移します。

また、リクエストされたURLからクエリ文字列を分離して処理します。

## 問題点

- nc の構造上、TCPヘッダの内容に触れないので接続元IPを取得するのは困難です。
- 名前付きパイプを使い、パイプがクローズされるかどうかをリクエストの開始終了に割り当てている関係で、POSTへの適切な対応が困難です。HTTP 1.0 では Content-Length が必須とされているので、がんばればできるかもしれません。read では読み取るバイト数が指定できます。
- bash で処理しているのですが入力文字列の検証をしていないため、コマンドインジェクションに対して非常に脆弱です。

